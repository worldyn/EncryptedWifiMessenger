#include <pic32mx.h>
#include <stdint.h>
#include "i2c.h"
#include "settings.h"

void i2c_setup() {
  I2C1CON = 0x0;
  /* I2C Baud rate should be less than 400 kHz, is generated by dividing
  the 40 MHz peripheral bus clock down */
  I2C1BRG = 0x0C2;
  I2C1STAT = 0x0;
  I2C1CONSET = 1 << 13; //SIDL = 1
  I2C1CONSET = 1 << 15; // ON = 1
}

/* Wait for I2C bus to become idle */
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* Send one byte on I2C bus, return ack/nack status of transaction */
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data;
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */

void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

int it = 1;
void master_try_read() {
  // Send start cond to see if slave want to send data  
  do {
    i2c_start();
  } while(!(i2c_send((SLAVE_ADDR << 1) | 1)));
  //if (!i2c_send((SLAVE_ADDR << 1) | 1)) {
  //  crash(0,0,0,"ack not recieved");
  //}
  
  // Number of bytes that will be recieved from slave
  uint16_t amount = i2c_recv() << 8;
  i2c_ack();
  amount |= i2c_recv();
  PORTE = amount + 1;
  if (amount) {
    i2c_ack();
    uint8_t i;
    // ack all recieves except last which should be nack
    for (i = 0; i < amount-1; ++i) {
      buf[i] = i2c_recv();      
      i2c_ack();
    }
    buf[amount-1] = i2c_recv();
    i2c_nack();
    i2c_stop();
    master_handle_read(amount, buf);
  } else { 
    i2c_nack();
    i2c_stop();
  }
}

void master_handle_read(const uint16_t len, uint8_t data[len]) {
  // show message  
  char str[len+1];
  str[len] = 0;
  uint16_t i;
  for (i = 0; i < len; ++i) {
    str[i] = data[i];
  }
  display_string(2, str);
  display_update();
}

void master_write(uint8_t data[], uint16_t len) {
  PORTE = 64;
  do {
    i2c_start();    
  } while (!i2c_send(SLAVE_ADDR << 1));

  PORTE = 63;
  uint8_t i;
  for (i = 0; i < len; ++i) {
    i2c_send(data[i]);
  }
  i2c_nack();
  i2c_stop();
  PORTE = 128;
}

